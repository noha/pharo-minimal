Object subclass: #ToolRegistry	instanceVariableNames: 'tools announcer'	classVariableNames: ''	poolDictionaries: ''	category: 'Tool-Registry'!!ToolRegistry commentStamp: '' prior: 0!I am serving as a system-wide hub for various tools.Instead of using direct class names for tools, which is not always nice because can introduce inter-packagedependencies, i provide a uniform way for accessing tools, via Smalltalk global:Smalltalk tools someToolName,where 'someToolName' is a name of the tool , under which some tool are registered.Tools are adding themselves to registry by implementing #registerToolsOn: message at class side, for example:MyClass>>registerToolsOn: registry   registry register: self as: #myToolRegisters a MyClass as a tool under name #myTool, and can be accessed via:Smalltalk tools myTool and avoid putting 'MyClass' reference into code.You can add  ' self registerToolsOn: Smalltalk tools ' in class #initialize,so your new tool(s) can be registered during package loading.To reset tool registry to defaults , use: Smalltalk resetTools.Also registry storing a map of inspector types. This is to replace an old scheme which using #inspectorClass , and introducing dependencies.Now, an inspecting class dont needs to have any knowledge about its specialized inspector.Instead, a specialized inspector could tell registry that it is available for inspecting instances of given class (see #registerInspector:for:  senders).This allows to avoid dependency from instance class to its inspector class or using extension methods.WARNING: The point of the tools registry is NOT to be a facade full of protocols but to be a registration for tools that get loaded. So, the tools registry should NOT hold specific tool's protocol.  the tool's client should invoke the correct methods of the tool.----------- The category 'menu' is for backward compatibility with ToolSet. We should remove it.!!ToolRegistry methodsFor: '*GT-Debugger-Model'!registeredDebuggersWithRanks		^ tools at: #debuggers ifAbsent: [		tools at: #debuggers put: OrderedCollection new ]! !!ToolRegistry methodsFor: '*GT-Debugger-Model'!debuggersMatching: aBlock	^ (self debuggersWithRanksMatching: aBlock) 			inject: OrderedCollection new			into: [ :aCollection :aPair | aCollection add: aPair key; yourself ]! !!ToolRegistry methodsFor: '*GT-Debugger-Model'!debuggersForContext: aContext	^ self debuggersMatching: [ :aDebugger | aDebugger handlesContext: aContext ]! !!ToolRegistry methodsFor: '*GT-Debugger-Model'!debuggerDispatcherFor: aContext matching: aBlock	| debuggers |	debuggers := self debuggersWithRanksMatching: [ :aDebugger | 		(aBlock value: aDebugger) and: [ 			aDebugger handlesContext: aContext ] ].	(debuggers size > 0) ifTrue: [ ^ (debuggers at: 1) key ].	^ nil! !!ToolRegistry methodsFor: '*GT-Debugger-Model'!registerDebugger: anObject withRank: anInteger	|debuggers|		debuggers  := tools at: #debuggers ifAbsent: [		tools at: #debuggers put: OrderedCollection new ]. 	(debuggers anySatisfy: [:each| each key == anObject] ) ifFalse: [ 		debuggers add: anObject -> anInteger ].	self announcer announce: (ToolRegistryToolRegistered tool: anObject name: #debuggers) ! !!ToolRegistry methodsFor: '*GT-Debugger-Model'!debuggersWithRanksMatching: aBlock	^ ((self registeredDebuggersWithRanks) 			select: [ :aPair | aBlock value: aPair key ])			sort: [ :pair1 :pair2 | pair1 value > pair2 value ].! !!ToolRegistry methodsFor: 'misc'!informNoDebugger	(self includes: #uiManager) 		ifTrue: [			self uiManager inform: 'Cannot open debugger' ]		ifFalse: [			"If we throw an exception here, this can lead to recursion.			Any idea what else we can do here?"			Processor activeProcess terminate ]! !!ToolRegistry methodsFor: 'misc'!codeCompletionAround: aBlock textMorph: aTextMorph keyStroke: evt	^(self hasToolNamed: #codeCompletion)	ifTrue: [ self codeCompletion codeCompletionAround: aBlock textMorph: aTextMorph keyStroke: evt ]	ifFalse: [ aBlock value ]! !!ToolRegistry methodsFor: 'misc'!browseDirectToolReferences	"Smalltalk tools browseDirectToolReferences"	"Browse all direct references of all of my registered tools.	Useful for converting calls like:		MyTool foo	into:		Smalltalk tools myTool foo 	"		| bindings |		bindings := tools values select: [:each | each value isBehavior ]		thenCollect: [:each | each value binding ].	bindings := bindings copyWith: (Smalltalk bindingOf: #ToolSet).	^  SystemNavigation new		browseMessageList: (			SystemNavigation new allMethodsSelect: [:m |				(m literals select: [:lit| lit isVariableBinding ]) includesAnyOf: bindings ] )		name: 'All direct references to tools to fix'! !!ToolRegistry methodsFor: 'misc'!using: aToolName do: aBlock	"Evaluate a block for tool found under corresponding name or silently ignore if its not found or nil"	| tool |		tool := tools at: aToolName ifAbsent: [ ^ self ].	tool ifNotNil: [ ^ aBlock value: tool value ]! !!ToolRegistry methodsFor: 'handling DNU'!doesNotUnderstand: aMessage	"Return a tool identified by a message selector.	We need to handle special case, when no debugger registered.	"	| tool |	tool := tools at: aMessage selector ifAbsent: nil.	tool ifNotNil: [ ^ tool value ].	^ (aMessage selector == #debugger) 		ifTrue: [ 			Smalltalk 				logError: 'No debugger installed to handle debug request.' 				inContext: thisContext.					nil. "Smalltalk snapshot: false andQuit: true."		]		ifFalse: [ super doesNotUnderstand: aMessage ]! !!ToolRegistry methodsFor: 'announcer'!whenToolRegistered: aBlock	self announcer weak when: ToolRegistryToolRegistered do: aBlock ! !!ToolRegistry methodsFor: 'announcer'!resetAnnouncer	"unregister all current weak subscriptions because it can cause a memory leak"	announcer subscriptions subscriptions 		select: [:each | each isKindOf: WeakAnnouncementSubscription] 		thenDo: [:each | each weakRegistry remove: each subscriber ifAbsent: []]. 	Smalltalk garbageCollect.			announcer := nil.! !!ToolRegistry methodsFor: 'announcer'!whenToolUnregistered: aBlock	self announcer weak when: ToolRegistryToolUnregistered do: aBlock ! !!ToolRegistry methodsFor: 'announcer'!announcer	announcer ifNil: [ announcer := Announcer new ].		^ announcer! !!ToolRegistry methodsFor: 'menu'!openFileList	self fileList open! !!ToolRegistry methodsFor: 'menu'!openClassBrowser	^ self browser open! !!ToolRegistry methodsFor: 'menu'!openTranscript	^ self transcript open! !!ToolRegistry methodsFor: 'menu'!menuItems	"Answer the menu items available for this tool set"	^#(		('System Browser' 			#openClassBrowser)		-		('Playground'				#openWorkspace)		('Transcript' 				#openTranscript)		('File Browser'				#openFileList)		-		('Test Runner'				#openTestRunner)		('Process Browser' 			#openProcessBrowser)		-		('Monticello Browser'		#openMonticelloBrowser)		('Change Sorter'			#openChangeSorter)	)! !!ToolRegistry methodsFor: 'menu'!openMonticelloBrowser	self monticelloBrowser open	! !!ToolRegistry methodsFor: 'menu'!openProcessBrowser	self using: #processBrowser do: [:tool |		tool open		]! !!ToolRegistry methodsFor: 'menu'!openWorkspace	^ self workspace open! !!ToolRegistry methodsFor: 'menu'!openRecentChangesLog	self changeList browseRecentLog! !!ToolRegistry methodsFor: 'menu'!openTestRunner	self using: #testRunner do: [:tool | tool open ]! !!ToolRegistry methodsFor: 'initialization'!initialize	"symbols used as keys "	tools := IdentityDictionary new.  		self initDefaultToolSet! !!ToolRegistry methodsFor: 'initialization'!initDefaultToolSet		"Query the system for registering tools"	"we cannot afford to show warnings because not all tools e.g Debugger, Inspector are registered yet"		[		Object withAllSubclassesDo: [:ea | 	"evaluate only for classes which directly implement this message,	not via subclassing"		(ea isMeta  and: [			ea includesSelector: #registerToolsOn: ]) ifTrue: [			 ea instanceSide registerToolsOn: self  ]].	] on: Warning do: [:ex | ex resume ]! !!ToolRegistry methodsFor: 'tools'!transcript	"No need to register transcript. But for uniformity,	implement this method, so transcript can be accessed via	Smalltalk tools transcript , as any other tool "	^ Transcript! !!ToolRegistry methodsFor: 'tools'!inspector	"understand by Object, so we need to work around not getting a DNU"	^self doesNotUnderstand: (Message selector: #inspector)! !!ToolRegistry methodsFor: 'registration'!remove: aName	| toolToRemove |		"remove tool with given name"	toolToRemove := tools removeKey: aName ifAbsent: [].	self announcer announce: (ToolRegistryToolRegistered tool: toolToRemove name: aName) ! !!ToolRegistry methodsFor: 'registration'!register: anObject as: aNameSelector	"Register a tool class under given name"	tools at: aNameSelector put: anObject.	self announcer announce: (ToolRegistryToolRegistered tool: anObject name: aNameSelector) ! !!ToolRegistry methodsFor: 'testing'!hasToolNamed: aToolName	^ tools includesKey: aToolName ! !ToolRegistry subclass: #PharoCommonTools	instanceVariableNames: 'recentTools'	classVariableNames: ''	poolDictionaries: ''	category: 'Tool-Registry'!!PharoCommonTools commentStamp: '' prior: 0!A PharoCommonTools is a ToolRegistry that knows about common tools that may be replaced by other packages. It manages a list of the recently registered tools and provides settings for reregistering to a former registered tool.!!PharoCommonTools methodsFor: 'cleanup'!cleanUp	recentTools keysAndValuesDo:[:name :toolSet|		toolSet copy do:[:tool | tool isObsolete ifTrue:[ toolSet remove: tool]]]! !!PharoCommonTools methodsFor: 'registration'!recentVersionBrowserTools	^ self recentToolsFor: #versionBrowser! !!PharoCommonTools methodsFor: 'registration'!recentToolsFor: aName	^ (recentTools at: aName ifAbsent: [ {} ]) reject: [ :tool | tool isObsolete ]! !!PharoCommonTools methodsFor: 'registration'!recentDebuggerTools	^ self recentToolsFor: #debugger! !!PharoCommonTools methodsFor: 'registration'!recentChangeSorterTools	^ self recentToolsFor: #changeSorter! !!PharoCommonTools methodsFor: 'registration'!recentBrowserTools	^ self recentToolsFor: #browser! !!PharoCommonTools methodsFor: 'registration'!register: anTool as: aNameSelector	| usedToolSet |	anTool ifNil:[ ^ self].	super register: anTool as: aNameSelector.	usedToolSet := recentTools at: aNameSelector ifAbsentPut: [ Set new ].	usedToolSet add: anTool! !!PharoCommonTools methodsFor: 'registration'!recentMessageListTools	^ self recentToolsFor: #messageList! !!PharoCommonTools methodsFor: 'registration'!recentInspectorTools	^ self recentToolsFor: #inspector! !!PharoCommonTools methodsFor: 'registration'!recentFileListTools	^ self recentToolsFor: #fileList! !!PharoCommonTools methodsFor: 'registration'!recentWorkspaceTools	^ self recentToolsFor: #workspace! !!PharoCommonTools methodsFor: 'tools'!versionBrowserTool: aTool	^ self register: aTool as: #versionBrowser! !!PharoCommonTools methodsFor: 'tools'!debuggerTool	^ self debugger! !!PharoCommonTools methodsFor: 'tools'!inspectorTool	^ self inspector! !!PharoCommonTools methodsFor: 'tools'!browserTool: aTool	^ self register: aTool as: #browser! !!PharoCommonTools methodsFor: 'tools'!browserTool	^ self browser! !!PharoCommonTools methodsFor: 'tools'!workspaceTool	^ self workspace! !!PharoCommonTools methodsFor: 'tools'!debuggerTool: aTool	^ self register: aTool as: #debugger! !!PharoCommonTools methodsFor: 'tools'!fileListTool: aTool	^ self register: aTool as: #fileList! !!PharoCommonTools methodsFor: 'tools'!messageListTool	^ self messageList! !!PharoCommonTools methodsFor: 'tools'!versionBrowserTool	^ self versionBrowser! !!PharoCommonTools methodsFor: 'tools'!messageListTool: aTool	^ self register: aTool as: #messageList! !!PharoCommonTools methodsFor: 'tools'!workspaceTool: aTool	^ self register: aTool as: #workspace! !!PharoCommonTools methodsFor: 'tools'!changeSorterTool	^ self changeSorter! !!PharoCommonTools methodsFor: 'tools'!changeSorterTool: aTool	^ self register: aTool as: #changeSorter! !!PharoCommonTools methodsFor: 'tools'!inspectorTool: aTool	^ self register: aTool as: #inspector! !!PharoCommonTools methodsFor: 'tools'!fileListTool	^ self fileList! !!PharoCommonTools methodsFor: 'initialization'!initialize	recentTools := Dictionary new.	super initialize.	! !!PharoCommonTools methodsFor: 'private'!toolNamed: aSymbol	tools at: aSymbol ifPresent: [ :tool | ^ tool ].		aSymbol = #debugger ifTrue: [ 		Smalltalk 			logError: 'No debugger installed to handle debug request.' 			inContext: thisContext.					^ nil. "Smalltalk snapshot: false andQuit: true."	].	self error: 'No tool named: "' , aSymbol , '" present in the registry'.! !!PharoCommonTools methodsFor: 'registry access'!debugger	^ self toolNamed: #debugger! !!PharoCommonTools methodsFor: 'registry access'!debuggers	^ self toolNamed: #debuggers! !!PharoCommonTools methodsFor: 'registry access'!syntaxErrorDebugger	^ self toolNamed: #syntaxErrorDebugger! !!PharoCommonTools methodsFor: 'registry access'!versionBrowser	^ self toolNamed: #versionBrowser! !!PharoCommonTools methodsFor: 'registry access'!pointerExplorer	^ self toolNamed: #pointerExplorer! !!PharoCommonTools methodsFor: 'registry access'!workspace	^ self toolNamed: #workspace! !!PharoCommonTools methodsFor: 'registry access'!basicInspector	^ self toolNamed: #basicInspector! !!PharoCommonTools methodsFor: 'registry access'!messageList	^ self toolNamed: #messageList! !!PharoCommonTools methodsFor: 'registry access'!monticelloBrowser	^ self toolNamed: #monticelloBrowser! !!PharoCommonTools methodsFor: 'registry access'!inspector	^ self toolNamed: #inspector! !!PharoCommonTools methodsFor: 'registry access'!codeCompletion	^ self toolNamed: #codeCompletion! !!PharoCommonTools methodsFor: 'registry access'!fileList	^ self toolNamed: #fileList! !!PharoCommonTools methodsFor: 'registry access'!browser	^ self toolNamed: #browser! !!PharoCommonTools methodsFor: 'registry access'!timeProfiler	^ self toolNamed: #timeProfiler! !!PharoCommonTools methodsFor: 'registry access'!processBrowser	^ self toolNamed: #processBrowser! !!PharoCommonTools methodsFor: 'registry access'!testRunner	^ self toolNamed: #testRunner! !!PharoCommonTools methodsFor: 'registry access'!changeList	^ self toolNamed: #changeList! !!PharoCommonTools methodsFor: 'registry access'!finder	^ self toolNamed: #finder! !!PharoCommonTools methodsFor: 'registry access'!changeSorter	^ self toolNamed: #changeSorter! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PharoCommonTools class	instanceVariableNames: ''!!PharoCommonTools class methodsFor: 'initialization'!initialize	SessionManager default		registerToolClassNamed: self name! !!PharoCommonTools class methodsFor: 'system startup'!shutDown: aboutToQuit	self allInstancesDo: #cleanUp! !!PharoCommonTools class methodsFor: 'settings'!settingsOn: aBuilder	<systemsettings>	Smalltalk tools class == self		ifFalse: [ ^ self ].	(aBuilder group: #pharoTools)		parent: #pharoSystem;		label: 'Recent Tools';		description: 'Recently registered Tools';		with: [ 					(aBuilder pickOne: #browserTool)						target: Smalltalk;						targetSelector: #tools;						getSelector: #browserTool;						setSelector: #browserTool:;						label: 'Systembrowser';						domainValues: Smalltalk tools recentBrowserTools ];		with: [ 					(aBuilder pickOne: #inspectorTool)						target: Smalltalk;						targetSelector: #tools;						getSelector: #inspectorTool;						setSelector: #inspectorTool:;						label: 'Inspector';						domainValues: Smalltalk tools recentInspectorTools ];		with: [ 					(aBuilder pickOne: #workspaceTool)						target: Smalltalk;						targetSelector: #tools;						getSelector: #workspaceTool;						setSelector: #workspaceTool:;						label: 'Workspace';						domainValues: Smalltalk tools recentWorkspaceTools ];		with: [ 					(aBuilder pickOne: #debuggerTool)						target: Smalltalk;						targetSelector: #tools;						label: 'Debugger';						domainValues: Smalltalk tools recentDebuggerTools ];		with: [ 					(aBuilder pickOne: #messageListTool)						target: Smalltalk;						targetSelector: #tools;						label: 'Messagelist';						domainValues: Smalltalk tools recentMessageListTools ];		with: [ 					(aBuilder pickOne: #versionBrowserTool)						target: Smalltalk;						targetSelector: #tools;						label: 'Versionbrowser';						domainValues: Smalltalk tools recentVersionBrowserTools ];		with: [ 					(aBuilder pickOne: #fileListTool)						target: Smalltalk;						targetSelector: #tools;						label: 'Filelist';						domainValues: Smalltalk tools recentFileListTools];		with: [ 					(aBuilder pickOne: #changeSorterTool)						target: Smalltalk;						targetSelector: #tools;						label: 'Changesorter';						domainValues: Smalltalk tools recentChangeSorterTools]! !!PharoCommonTools class methodsFor: 'settings'!browsingSettingsOn: aBuilder	<systemsettings>		"create empty #codeBrowsing and #qualityAssistant settings groups so the tools can use it"		(aBuilder group: #codeBrowsing)		label: 'Code Browsing';		description: 'All settings concerned with code browsing look''n feel'.		(aBuilder group: #qualityAssistant)		label: 'QualityAssistant';		parent: #codeBrowsing.! !!PharoCommonTools class methodsFor: 'world menu'!worldMenuOn: aBuilder	<worldMenu>	(aBuilder item: #'System Browser')		parent: #Tools;		action: [ Smalltalk tools openClassBrowser ];		order: 0;		keyText: 'o, b';		help: 'System browser to browse and edit code.';		iconName: #smallSystemBrowser! !Announcement subclass: #ToolRegistryAnnouncement	instanceVariableNames: 'tool name'	classVariableNames: ''	poolDictionaries: ''	category: 'Tool-Registry'!!ToolRegistryAnnouncement commentStamp: '' prior: 0!An abstract announcement class for tool registry announcements!!ToolRegistryAnnouncement methodsFor: 'accessing'!tool	^ tool! !!ToolRegistryAnnouncement methodsFor: 'accessing'!name: anObject	name := anObject! !!ToolRegistryAnnouncement methodsFor: 'accessing'!tool: anObject	tool := anObject! !!ToolRegistryAnnouncement methodsFor: 'accessing'!name	^ name! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ToolRegistryAnnouncement class	instanceVariableNames: ''!!ToolRegistryAnnouncement class methodsFor: 'instance creation'!tool: aTool name: aSymbol	^ self new 		tool: aTool;		name: aSymbol;		yourself! !ToolRegistryAnnouncement subclass: #ToolRegistryToolRegistered	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tool-Registry'!!ToolRegistryToolRegistered commentStamp: '' prior: 0!This announcement will be emitted when a new tool is registered.!ToolRegistryAnnouncement subclass: #ToolRegistryToolUnregistered	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tool-Registry'!!ToolRegistryToolUnregistered commentStamp: '' prior: 0!This announcement will be emitted when a tool is unregistered.!PharoCommonTools initialize!'From Pharo8.0.0 of 11 March 2019 [Build information: Pharo-8.0.0+build.127.sha.15c62df95524ef46e6d76ec21e8ee4580309f227 (64 Bit)] on 11 March 2019 at 5:12:03.864982 pm'!!SmalltalkImage methodsFor: '*Tool-Registry'!tools	^ Tools ifNil: [		Tools := PharoCommonTools new ]! !