Object subclass: #SortFunction	instanceVariableNames: ''	classVariableNames: 'Default'	poolDictionaries: ''	category: 'SortFunctions-Core'!!SortFunction commentStamp: '' prior: 0!I am intended to be used in place of two arg sort blocks.UsageIn the following example, an ascending SortFunction is created based on the result of the #first message send to each object.#(#(1 2) #(2 3) #(0 0)) sorted: #first ascending.To sort by the #last element, but descending, the following would be used:#(#(1 2) #(2 3) #(0 0)) sorted: #last descending.One can use blocks as well. The following sorts in descending order, the sub elements based on the sum of their values.| sumBlock |sumBlock := [:sequence | sequence inject: 0 into: [:sum :each | sum + each]].#(#(1 2) #(2 3) #(0 0)) sorted: sumBlock descending.One can even use 2 arg blocks, for those cases where the function isn't expressible with objects that respond to < and =. The only catch, is that such a function has to return not true and false, but instead a collation order, values of -1 (for before), 0 (the same) or 1 (to follow). For example:| oddBlock |oddBlock :=		[:a :b |		a odd = b odd ifTrue: [0] ifFalse: [a odd ifTrue: [-1] ifFalse: [1]]].#(1 5 1 3 2 7 9 4 6) asSortedCollection: oddBlock descendingUsing #undefinedFirst and #undefinedLast it is possible to deal with nil values, moving them first or last. For Example:#(a nil z b) sorted: #value ascending undefinedFirst.#(a nil z b) sorted: #value ascending undefinedLast.Different scenarios are implemented by my different subclasses:- SortByPropertyFunction implement property comparison by selector or block- CollatorBlockFunction represent two args collator block- and ChainedSortFunction implements composition of collators created by comma messageApplications can implement their own domain sort functions defining the method:	collate: anObject1 with: anObject2!!SortFunction methodsFor: 'converting'!asSortFunction	^self! !!SortFunction methodsFor: 'converting'!reversed	"Return new sort function with reverse sort order."	^ReverseSortFunction on: self! !!SortFunction methodsFor: 'converting'!undefinedLast	"Return a new SortFunction that sort all the nil last, an non nil with myself."	^(UndefinedSortFunction on: self) undefinedLast! !!SortFunction methodsFor: 'converting'!, aSortFunction	"Return a new SortFunction which is the concatenation of aSortFunction to me, I will be the primary sort, but if I compare equal, I will defer to the argument."	^ChainedSortFunction startWith: self then: aSortFunction asSortFunction! !!SortFunction methodsFor: 'converting'!undefinedFirst	"Return a new SortFunction that sort all the nil first, an non nil with myself."	^(UndefinedSortFunction on: self) undefinedFirst! !!SortFunction methodsFor: 'evaluating'!value: anObject1 value: anObject2	"Masquerade as a two argument block, used by many of the sorting APIs, 	by returning whether anObject1 should be placed before anObject2 or not"	| result |	result := self collate: anObject1 with: anObject2.	^result <= 0! !!SortFunction methodsFor: 'evaluating'!collate: anObject1 with: anObject2	"Do a three-way comparison between the anObject1 and anObject2, returning	-1 if anObject1 < anObject2	0 if anObject1 = anObject2	1 if anObject1 > anObject2	This assumes a total order in accordance with the mathematical law of trichotomy.	See also:  http://en.wikipedia.org/wiki/Three-way_comparison"	self subclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SortFunction class	instanceVariableNames: ''!!SortFunction class methodsFor: 'accessing'!default	^Default! !SortFunction subclass: #CollatorBlockFunction	instanceVariableNames: 'collatorBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'SortFunctions-Core'!!CollatorBlockFunction commentStamp: '' prior: 0!I represent two args collator block which must return 1, -1 or 0.Usually I am created directly from block using sorting messages:	[:a :b | ] ascending	[:a :b | ] descending.Look at SortFunction comments for more details.Internal Representation and Key Implementation Points.    Instance Variables	collatorBlock:		<BlockClosure>	This is the collation function that must return a -1, 0, or 1!!CollatorBlockFunction methodsFor: 'comparing'!hash	"Answer an integer value that is related to the identity of the receiver."	^ collatorBlock hash! !!CollatorBlockFunction methodsFor: 'comparing'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^collatorBlock = anObject collatorBlock! !!CollatorBlockFunction methodsFor: 'accessing'!collatorBlock: anObject	collatorBlock := anObject! !!CollatorBlockFunction methodsFor: 'accessing'!collatorBlock	^ collatorBlock! !!CollatorBlockFunction methodsFor: 'evaluating'!collate: anObject1 with: anObject2	^collatorBlock value: anObject1 value: anObject2 ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CollatorBlockFunction class	instanceVariableNames: ''!!CollatorBlockFunction class methodsFor: 'instance creation'!usingBlock: twoArgsBlock	^self new 		collatorBlock: twoArgsBlock! !SortFunction subclass: #ComposedSortFunction	instanceVariableNames: 'baseSortFunction'	classVariableNames: ''	poolDictionaries: ''	category: 'SortFunctions-Core'!!ComposedSortFunction commentStamp: '' prior: 0!A ComposedSortFunction is an abstract class wrapping over another SortFunction for the sake of composition.Subclasses have to define the composition behavior via collate:with: message.Instances variables:	baseSortFunction		<SortFunction>	the wrapped sort function!!ComposedSortFunction methodsFor: 'initailize-release'!initialize	super initialize.	baseSortFunction := self class default! !!ComposedSortFunction methodsFor: 'comparing'!hash	^baseSortFunction hash hashMultiply! !!ComposedSortFunction methodsFor: 'comparing'!= aSortFunction	self == aSortFunction ifTrue: [ ^true ].	^self class = aSortFunction class and: [ baseSortFunction = aSortFunction baseSortFunction ]! !!ComposedSortFunction methodsFor: 'accessing'!baseSortFunction	^baseSortFunction! !!ComposedSortFunction methodsFor: 'accessing'!baseSortFunction: aSortFunction	baseSortFunction := aSortFunction! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ComposedSortFunction class	instanceVariableNames: ''!!ComposedSortFunction class methodsFor: 'instance creation'!on: aSortFunction	^self new baseSortFunction: aSortFunction! !ComposedSortFunction subclass: #ChainedSortFunction	instanceVariableNames: 'nextFunction'	classVariableNames: ''	poolDictionaries: ''	category: 'SortFunctions-Core'!!ChainedSortFunction commentStamp: '' prior: 0!I add to my parent the idea of a "next" function to use when two objects are equal by my primary sort function.UsageSortFunctions can be chained together in primary, secondary, tertiary, etc order using the comma method. Consider a sequence of customer objects, where each customer object responds to the messages firstName, lastName, and age. If we want to sort them lastName first, then firstName, and finally oldest first, we would use an expression like:customers sort: #lastName ascending, #firstName ascending, #age descendingAs noted in my super's comment, unary symbols or single arg blocks can be used. One can omit the the ascending methods on arguments (not the receiver), it will default blocks or symbols to be ascending if none is specified. In other words, the above expression could be simplified slightly ascustomers sort: #lastName ascending, #firstName, #age descending(note the missing ascending on the #firstName argument)Instance Variables	baseSortFunction	<SortFunction> the primary SortFunction to collate given objects	next	Function	<SortFunction>	the next SortFunction to evaluate in the event primary collation results are equal values!!ChainedSortFunction methodsFor: 'converting'!, aSortFunction	^self class startWith: baseSortFunction then: nextFunction , aSortFunction! !!ChainedSortFunction methodsFor: 'accessing'!nextFunction	^ nextFunction! !!ChainedSortFunction methodsFor: 'accessing'!nextFunction: anObject	nextFunction := anObject! !!ChainedSortFunction methodsFor: 'evaluating'!collate: anObject1 with: anObject2	"If the result of current function is 0, then pass on to the next function to work it out"	| result |	result := baseSortFunction collate: anObject1 with: anObject2.	^result isZero		ifTrue: [nextFunction collate: anObject1 with: anObject2.]		ifFalse: [result]! !!ChainedSortFunction methodsFor: 'comparing'!hash	"Answer an integer value that is related to the identity of the receiver."	^ super hash + nextFunction hash! !!ChainedSortFunction methodsFor: 'comparing'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ baseSortFunction = anObject baseSortFunction			and: [ nextFunction = anObject nextFunction ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ChainedSortFunction class	instanceVariableNames: ''!!ChainedSortFunction class methodsFor: 'instance creation'!startWith: aSortFunction then: nextSortFunction	^self new		baseSortFunction: aSortFunction;		nextFunction: nextSortFunction! !SortFunction subclass: #DefaultSortFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SortFunctions-Core'!!DefaultSortFunction commentStamp: '' prior: 0!A DefaultSortFunction is a collator using the default threeWayCompareTo: operator.It is known to work on String and Magnitude.It is generally not usefull to create a new instance, and the recommended pattern is to use the single instance available by sending the message  SortFunction default .For other objects  that don't understand threeWayCompareTo: it is necessary to use a custom SortFunction rather than the default one.!!DefaultSortFunction methodsFor: 'evaluating'!collate: anObject with: anotherObject	^anObject threeWayCompareTo: anotherObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DefaultSortFunction class	instanceVariableNames: ''!!DefaultSortFunction class methodsFor: 'class initialization'!initialize	Default := self new! !ComposedSortFunction subclass: #PropertySortFunction	instanceVariableNames: 'property'	classVariableNames: ''	poolDictionaries: ''	category: 'SortFunctions-Core'!!PropertySortFunction commentStamp: '' prior: 0!I implement collation of objects using their property. Property is defined by selector or one arg block which can be converted directly to my instances:	#name ascending.	#name descending.	[:a | a name] ascending	[:a | a name] descendingLook at SortFunction comments for more details.Internal Representation and Key Implementation Points.    Instance Variables	property		<Symbol, BlockClosure>!!PropertySortFunction methodsFor: 'evaluating'!collate: anObject with: another	^ baseSortFunction collate: (property value: anObject) with: (property value: another)! !!PropertySortFunction methodsFor: 'comparing'!hash	"Answer an integer value that is related to the identity of the receiver."	^ super hash bitXor: property hash! !!PropertySortFunction methodsFor: 'comparing'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ baseSortFunction = anObject baseSortFunction		and: [ property = anObject property ]! !!PropertySortFunction methodsFor: 'accessing'!property	^ property! !!PropertySortFunction methodsFor: 'accessing'!property: aValuable	property := aValuable! !!PropertySortFunction methodsFor: 'converting'!undefinedLast	"apply on the property"	^self class		property: property		collatedWith: baseSortFunction undefinedLast! !!PropertySortFunction methodsFor: 'converting'!undefinedFirst	"apply on the property"	^self class		property: property		collatedWith: baseSortFunction undefinedFirst! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PropertySortFunction class	instanceVariableNames: ''!!PropertySortFunction class methodsFor: 'instance creation'!property: selectorOrOneArgBlock collatedWith: aSortFunction	^self new 		property: selectorOrOneArgBlock;		baseSortFunction: aSortFunction! !!PropertySortFunction class methodsFor: 'instance creation'!property: selectorOrOneArgBlock	^self new 		property: selectorOrOneArgBlock! !ComposedSortFunction subclass: #ReverseSortFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SortFunctions-Core'!!ReverseSortFunction commentStamp: '' prior: 0!A ReverseSortFunction wraps over another SortFunction so as to sort in reverse order.!!ReverseSortFunction methodsFor: 'converting'!undefinedLast	"apply on the original"	^baseSortFunction undefinedFirst reversed! !!ReverseSortFunction methodsFor: 'converting'!reversed	^baseSortFunction! !!ReverseSortFunction methodsFor: 'converting'!undefinedFirst	"apply on the original"	^baseSortFunction undefinedLast reversed! !!ReverseSortFunction methodsFor: 'evaluating'!collate: anObject with: another	^(baseSortFunction collate: anObject with: another) negated! !ComposedSortFunction subclass: #UndefinedSortFunction	instanceVariableNames: 'direction'	classVariableNames: ''	poolDictionaries: ''	category: 'SortFunctions-Core'!!UndefinedSortFunction commentStamp: '' prior: 0!An  UndefinedSortFunction is a specialization usefull for sorting undefined objects (nil), either first or last according to direction.The non nil objects are sorted according to the baseSortFunction defined in superclass.instance variables:	direction	<Integer>	-1 for sorting nil first, 1 for sorting nil last!!UndefinedSortFunction methodsFor: 'evaluating'!collate: anObject with: another	anObject ifNil: [^another ifNil: [0] ifNotNil: [direction]].	another ifNil: [^direction negated].	^baseSortFunction collate: anObject with: another! !!UndefinedSortFunction methodsFor: 'comparing'!hash	"Answer an integer value that is related to the identity of the receiver."	^ super hash bitXor: direction hash! !!UndefinedSortFunction methodsFor: 'comparing'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ baseSortFunction = anObject baseSortFunction		and: [ direction = anObject direction ]! !!UndefinedSortFunction methodsFor: 'accessing'!direction	^direction! !!UndefinedSortFunction methodsFor: 'initailize-release'!undefinedLast	direction := 1! !!UndefinedSortFunction methodsFor: 'initailize-release'!initialize	super initialize.	direction := -1! !!UndefinedSortFunction methodsFor: 'initailize-release'!undefinedFirst	direction := -1! !DefaultSortFunction initialize!'From Pharo7.0.2 of 5 March 2019 [Build information: Pharo-7.0.2+build.152.sha.890f474a81f116ead0e68c8de77790aef4e9a752 (64 Bit)] on 10 March 2019 at 1:30:56.361175 pm'!!Magnitude methodsFor: '*SortFunctions-Core-comparing'!threeWayCompareTo: anotherObject	"Do a three-way comparison between the receiver and anotherObject, returning	-1 if self < anotherObject	0 if self = anotherObject	1 if self > anotherObject	This assumes a total order in accordance with the mathematical law of trichotomy.	See also:  http://en.wikipedia.org/wiki/Three-way_comparison"	^ self = anotherObject		ifTrue: [ 0 ]		ifFalse: [ self < anotherObject				ifTrue: [ -1 ]				ifFalse: [ 1 ] ]! !'From Pharo7.0.2 of 5 March 2019 [Build information: Pharo-7.0.2+build.152.sha.890f474a81f116ead0e68c8de77790aef4e9a752 (64 Bit)] on 10 March 2019 at 1:30:56.363273 pm'!!Symbol methodsFor: '*SortFunctions-Core-converting'!descending	"Return a SortFunction around the receiver, where the receiver will be used as a unary message to send to both a and b during sorting, and then the result of said send will be collated in descending order using the <=> method."	"#('abc' 'de' 'fghi') sorted: #size ascending >>> #('fghi' 'abc' 'de')"	^self asSortFunction reversed! !'From Pharo7.0.2 of 5 March 2019 [Build information: Pharo-7.0.2+build.152.sha.890f474a81f116ead0e68c8de77790aef4e9a752 (64 Bit)] on 10 March 2019 at 1:30:56.364823 pm'!!Symbol methodsFor: '*SortFunctions-Core-converting'!asSortFunction	"Return a SortFunction around the receiver, where the receiver will be used as a unary message to send to both a and b during sorting, and then the result of said send will be collated in ascending order using the <=> method."	"#('abc' 'de' 'fghi') sorted: #size ascending >>> #('de' 'abc' 'fghi')"	^PropertySortFunction property: self! !'From Pharo7.0.2 of 5 March 2019 [Build information: Pharo-7.0.2+build.152.sha.890f474a81f116ead0e68c8de77790aef4e9a752 (64 Bit)] on 10 March 2019 at 1:30:56.365782 pm'!!Symbol methodsFor: '*SortFunctions-Core-converting'!collatedBy: aSortFunction	"Return a SortFunction around the receiver, where the receiver will be used as a unary message to send to both a and b during sorting, and then the result of said send will be collated iusing aSortFunction."	"#('abc' 'de' 'fghi') sorted: (#size collatedBy: [:e|e bitAnd: 1]) , #size >>> #( 'de' 'fghi' 'abc')"	^PropertySortFunction property: self collatedWith: aSortFunction asSortFunction! !'From Pharo7.0.2 of 5 March 2019 [Build information: Pharo-7.0.2+build.152.sha.890f474a81f116ead0e68c8de77790aef4e9a752 (64 Bit)] on 10 March 2019 at 1:30:56.366001 pm'!!Symbol methodsFor: '*SortFunctions-Core-converting'!ascending	"Return a SortFunction around the receiver, where the receiver will be used as a unary message to send to both a and b during sorting, and then the result of said send will be collated in ascending order using the <=> method."	"#('abc' 'de' 'fghi') sorted: #size ascending >>> #('de' 'abc' 'fghi')"	^self asSortFunction ! !'From Pharo7.0.2 of 5 March 2019 [Build information: Pharo-7.0.2+build.152.sha.890f474a81f116ead0e68c8de77790aef4e9a752 (64 Bit)] on 10 March 2019 at 1:30:56.366187 pm'!!BlockClosure methodsFor: '*SortFunctions-Core-converting'!descending	"Opposite direction as ascending."	^self asSortFunction reversed! !'From Pharo7.0.2 of 5 March 2019 [Build information: Pharo-7.0.2+build.152.sha.890f474a81f116ead0e68c8de77790aef4e9a752 (64 Bit)] on 10 March 2019 at 1:30:56.367105 pm'!!BlockClosure methodsFor: '*SortFunctions-Core-converting'!asSortFunction	"Return a SortFunction around the receiver. If the receiver is a 2 arg block, it is assumed it will do the collation directly itself, returning -1, 0, or 1. If the receiver is a one arg block, it will be evaluated for each a and b and of the sort input, and the result of sending <=> to those will be used"		self numArgs = 1 ifTrue: [^PropertySortFunction property: self].	self numArgs = 2 ifTrue: [^CollatorBlockFunction usingBlock: self].	self error: 'Cant be converted to sort function. It should has one or two args'	! !'From Pharo7.0.2 of 5 March 2019 [Build information: Pharo-7.0.2+build.152.sha.890f474a81f116ead0e68c8de77790aef4e9a752 (64 Bit)] on 10 March 2019 at 1:30:56.368373 pm'!!BlockClosure methodsFor: '*SortFunctions-Core-converting'!collatedBy: aSortFunction	"Return a SortFunction around the receiver. If the receiver is a 2 arg block, it is assumed it will do the collation directly itself, returning -1, 0, or 1. If the receiver is a one arg block, it will be evaluated for each a and b and of the sort input, and the result of using aSortFunction on those will be used"		self numArgs = 1 ifTrue: [^PropertySortFunction property: self collatedWith: aSortFunction asSortFunction].	self error: 'Cant be converted to sort function. It should hava one arg'	! !'From Pharo7.0.2 of 5 March 2019 [Build information: Pharo-7.0.2+build.152.sha.890f474a81f116ead0e68c8de77790aef4e9a752 (64 Bit)] on 10 March 2019 at 1:30:56.368746 pm'!!BlockClosure methodsFor: '*SortFunctions-Core-converting'!ascending	"Return a SortFunction around the receiver. If the receiver is a 2 arg block, it is assumed it will do the collation directly itself, returning -1, 0, or 1. If the receiver is a one arg block, it will be evaluated for each a and b and of the sort input, and the result of sending <=> to those will be used."	^self asSortFunction! !'From Pharo7.0.2 of 5 March 2019 [Build information: Pharo-7.0.2+build.152.sha.890f474a81f116ead0e68c8de77790aef4e9a752 (64 Bit)] on 10 March 2019 at 1:30:56.369085 pm'!!String methodsFor: '*SortFunctions-Core'!threeWayCompareTo: aString	"Do a three-way comparison between the receiver and anotherObject, returning	-1 if self < anotherObject	0 if self = anotherObject	1 if self > anotherObject	This assumes a total order in accordance with the mathematical law of trichotomy.	See also:  http://en.wikipedia.org/wiki/Three-way_comparison"	 ^ (self compare: self with: aString collated: AsciiOrder) - 2! !